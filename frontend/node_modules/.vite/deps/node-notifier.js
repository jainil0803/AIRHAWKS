import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-WXXH56N5.js";

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/shellwords/lib/shellwords.js
var require_shellwords = __commonJS({
  "node_modules/shellwords/lib/shellwords.js"(exports) {
    (function() {
      var scan;
      scan = function(string, pattern, callback) {
        var match, result;
        result = "";
        while (string.length > 0) {
          match = string.match(pattern);
          if (match) {
            result += string.slice(0, match.index);
            result += callback(match);
            string = string.slice(match.index + match[0].length);
          } else {
            result += string;
            string = "";
          }
        }
        return result;
      };
      exports.split = function(line) {
        var field, words;
        if (line == null) {
          line = "";
        }
        words = [];
        field = "";
        scan(line, /\s*(?:([^\s\\\'\"]+)|'((?:[^\'\\]|\\.)*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\s|$)?/, function(match) {
          var dq, escape, garbage, raw, seperator, sq, word;
          raw = match[0], word = match[1], sq = match[2], dq = match[3], escape = match[4], garbage = match[5], seperator = match[6];
          if (garbage != null) {
            throw new Error("Unmatched quote");
          }
          field += word || (sq || dq || escape).replace(/\\(?=.)/, "");
          if (seperator != null) {
            words.push(field);
            return field = "";
          }
        });
        if (field) {
          words.push(field);
        }
        return words;
      };
      exports.escape = function(str) {
        if (str == null) {
          str = "";
        }
        if (str == null) {
          return "''";
        }
        return str.replace(/([^A-Za-z0-9_\-.,:\/@\n])/g, "\\$1").replace(/\n/g, "'\n'");
      };
    }).call(exports);
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-notifier/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/node-notifier/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/node-notifier/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/node-notifier/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/node-notifier/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/node-notifier/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/node-notifier/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse2 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse2;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/valid.js"(exports, module) {
    var parse2 = require_parse();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/clean.js"(exports, module) {
    var parse2 = require_parse();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/diff.js"(exports, module) {
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse2 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/node-notifier/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/node-notifier/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/node-notifier/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/node-notifier/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/node-notifier/node_modules/semver/classes/range.js"(exports, module) {
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/node-notifier/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/node-notifier/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/node-notifier/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/node-notifier/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/node-notifier/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/node-notifier/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// node_modules/node-notifier/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/node-notifier/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/is-docker/index.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    var isDocker;
    function hasDockerEnv() {
      try {
        fs.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/is-wsl/index.js"(exports, module) {
    "use strict";
    var os = require_os();
    var fs = require_fs();
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module.exports = isWsl;
    } else {
      module.exports = isWsl();
    }
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-notifier/lib/utils.js
var require_utils = __commonJS({
  "node_modules/node-notifier/lib/utils.js"(exports, module) {
    var shellwords = require_shellwords();
    var cp = require_child_process();
    var semver = require_semver2();
    var isWSL = require_is_wsl();
    var path = require_path();
    var url = require_url();
    var os = require_os();
    var fs = require_fs();
    var net = require_net();
    var BUFFER_SIZE = 1024;
    function clone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    module.exports.clone = clone;
    var escapeQuotes = function(str) {
      if (typeof str === "string") {
        return str.replace(/(["$`\\])/g, "\\$1");
      } else {
        return str;
      }
    };
    var inArray = function(arr, val) {
      return arr.indexOf(val) !== -1;
    };
    var notifySendFlags = {
      u: "urgency",
      urgency: "urgency",
      t: "expire-time",
      time: "expire-time",
      timeout: "expire-time",
      e: "expire-time",
      expire: "expire-time",
      "expire-time": "expire-time",
      i: "icon",
      icon: "icon",
      c: "category",
      category: "category",
      subtitle: "category",
      h: "hint",
      hint: "hint",
      a: "app-name",
      "app-name": "app-name"
    };
    module.exports.command = function(notifier, options, cb) {
      notifier = shellwords.escape(notifier);
      if (process.env.DEBUG && process.env.DEBUG.indexOf("notifier") !== -1) {
        console.info("node-notifier debug info (command):");
        console.info("[notifier path]", notifier);
        console.info("[notifier options]", options.join(" "));
      }
      return cp.exec(notifier + " " + options.join(" "), function(error, stdout, stderr) {
        if (error)
          return cb(error);
        cb(stderr, stdout);
      });
    };
    module.exports.fileCommand = function(notifier, options, cb) {
      if (process.env.DEBUG && process.env.DEBUG.indexOf("notifier") !== -1) {
        console.info("node-notifier debug info (fileCommand):");
        console.info("[notifier path]", notifier);
        console.info("[notifier options]", options.join(" "));
      }
      return cp.execFile(notifier, options, function(error, stdout, stderr) {
        if (error)
          return cb(error, stdout);
        cb(stderr, stdout);
      });
    };
    module.exports.fileCommandJson = function(notifier, options, cb) {
      if (process.env.DEBUG && process.env.DEBUG.indexOf("notifier") !== -1) {
        console.info("node-notifier debug info (fileCommandJson):");
        console.info("[notifier path]", notifier);
        console.info("[notifier options]", options.join(" "));
      }
      return cp.execFile(notifier, options, function(error, stdout, stderr) {
        if (error)
          return cb(error, stdout);
        if (!stdout)
          return cb(error, {});
        try {
          const data = JSON.parse(stdout);
          cb(!stderr ? null : stderr, data);
        } catch (e) {
          cb(e, stdout);
        }
      });
    };
    module.exports.immediateFileCommand = function(notifier, options, cb) {
      if (process.env.DEBUG && process.env.DEBUG.indexOf("notifier") !== -1) {
        console.info("node-notifier debug info (notifier):");
        console.info("[notifier path]", notifier);
      }
      notifierExists(notifier, function(_, exists) {
        if (!exists) {
          return cb(new Error("Notifier (" + notifier + ") not found on system."));
        }
        cp.execFile(notifier, options);
        cb();
      });
    };
    function notifierExists(notifier, cb) {
      return fs.stat(notifier, function(err, stat) {
        if (!err)
          return cb(err, stat.isFile());
        if (path.extname(notifier)) {
          return cb(err, false);
        }
        return fs.stat(notifier + ".exe", function(err2, stat2) {
          if (err2)
            return cb(err2, false);
          cb(err2, stat2.isFile());
        });
      });
    }
    var mapAppIcon = function(options) {
      if (options.appIcon) {
        options.icon = options.appIcon;
        delete options.appIcon;
      }
      return options;
    };
    var mapText = function(options) {
      if (options.text) {
        options.message = options.text;
        delete options.text;
      }
      return options;
    };
    var mapIconShorthand = function(options) {
      if (options.i) {
        options.icon = options.i;
        delete options.i;
      }
      return options;
    };
    module.exports.mapToNotifySend = function(options) {
      options = mapAppIcon(options);
      options = mapText(options);
      if (options.timeout === false) {
        delete options.timeout;
      }
      if (options.wait === true) {
        options["expire-time"] = 5;
      }
      for (const key in options) {
        if (key === "message" || key === "title")
          continue;
        if (options.hasOwnProperty(key) && notifySendFlags[key] !== key) {
          options[notifySendFlags[key]] = options[key];
          delete options[key];
        }
      }
      if (typeof options["expire-time"] === "undefined") {
        options["expire-time"] = 10 * 1e3;
      } else if (typeof options["expire-time"] === "number") {
        options["expire-time"] = options["expire-time"] * 1e3;
      }
      return options;
    };
    module.exports.mapToGrowl = function(options) {
      options = mapAppIcon(options);
      options = mapIconShorthand(options);
      options = mapText(options);
      if (options.icon && !Buffer.isBuffer(options.icon)) {
        try {
          options.icon = fs.readFileSync(options.icon);
        } catch (ex) {
        }
      }
      return options;
    };
    module.exports.mapToMac = function(options) {
      options = mapIconShorthand(options);
      options = mapText(options);
      if (options.icon) {
        options.appIcon = options.icon;
        delete options.icon;
      }
      if (options.sound === true) {
        options.sound = "Bottle";
      }
      if (options.sound === false) {
        delete options.sound;
      }
      if (options.sound && options.sound.indexOf("Notification.") === 0) {
        options.sound = "Bottle";
      }
      if (options.wait === true) {
        if (!options.timeout) {
          options.timeout = 5;
        }
        delete options.wait;
      }
      if (!options.wait && !options.timeout) {
        if (options.timeout === false) {
          delete options.timeout;
        } else {
          options.timeout = 10;
        }
      }
      options.json = true;
      return options;
    };
    function isArray(arr) {
      return Object.prototype.toString.call(arr) === "[object Array]";
    }
    module.exports.isArray = isArray;
    function noop() {
    }
    module.exports.actionJackerDecorator = function(emitter, options, fn2, mapper) {
      options = clone(options);
      fn2 = fn2 || noop;
      if (typeof fn2 !== "function") {
        throw new TypeError(
          "The second argument must be a function callback. You have passed " + typeof fn2
        );
      }
      return function(err, data) {
        let resultantData = data;
        let metadata = {};
        if (resultantData && typeof resultantData === "object") {
          metadata = resultantData;
          resultantData = resultantData.activationType;
        }
        if (resultantData) {
          resultantData = resultantData.toLowerCase().trim();
          if (resultantData.match(/^activate|clicked$/)) {
            resultantData = "activate";
          }
          if (resultantData.match(/^timedout$/)) {
            resultantData = "timeout";
          }
        }
        fn2.apply(emitter, [err, resultantData, metadata]);
        if (!mapper || !resultantData)
          return;
        const key = mapper(resultantData);
        if (!key)
          return;
        emitter.emit(key, emitter, options, metadata);
      };
    };
    module.exports.constructArgumentList = function(options, extra) {
      const args = [];
      extra = extra || {};
      const initial = extra.initial || [];
      const keyExtra = extra.keyExtra || "";
      const allowedArguments = extra.allowedArguments || [];
      const noEscape = extra.noEscape !== void 0;
      const checkForAllowed = extra.allowedArguments !== void 0;
      const explicitTrue = !!extra.explicitTrue;
      const keepNewlines = !!extra.keepNewlines;
      const wrapper = extra.wrapper === void 0 ? '"' : extra.wrapper;
      const escapeFn = function escapeFn2(arg) {
        if (isArray(arg)) {
          return removeNewLines(arg.map(escapeFn2).join(","));
        }
        if (!noEscape) {
          arg = escapeQuotes(arg);
        }
        if (typeof arg === "string" && !keepNewlines) {
          arg = removeNewLines(arg);
        }
        return wrapper + arg + wrapper;
      };
      initial.forEach(function(val) {
        args.push(escapeFn(val));
      });
      for (const key in options) {
        if (options.hasOwnProperty(key) && (!checkForAllowed || inArray(allowedArguments, key))) {
          if (explicitTrue && options[key] === true) {
            args.push("-" + keyExtra + key);
          } else if (explicitTrue && options[key] === false)
            continue;
          else
            args.push("-" + keyExtra + key, escapeFn(options[key]));
        }
      }
      return args;
    };
    function removeNewLines(str) {
      const excapedNewline = process.platform === "win32" ? "\\r\\n" : "\\n";
      return str.replace(/\r?\n/g, excapedNewline);
    }
    var allowedToasterFlags = [
      "t",
      "m",
      "b",
      "tb",
      "p",
      "id",
      "s",
      "silent",
      "appID",
      "pid",
      "pipeName",
      "close",
      "install"
    ];
    var toasterSoundPrefix = "Notification.";
    var toasterDefaultSound = "Notification.Default";
    module.exports.mapToWin8 = function(options) {
      options = mapAppIcon(options);
      options = mapText(options);
      if (options.icon) {
        if (/^file:\/+/.test(options.icon)) {
          options.p = new url.URL(options.icon).pathname.replace(/^\/(\w:\/)/, "$1").replace(/\//g, "\\");
        } else {
          options.p = options.icon;
        }
        delete options.icon;
      }
      if (options.message) {
        options.m = options.message.replace(/\x1b/g, "");
        delete options.message;
      }
      if (options.title) {
        options.t = options.title;
        delete options.title;
      }
      if (options.appName) {
        options.appID = options.appName;
        delete options.appName;
      }
      if (typeof options.remove !== "undefined") {
        options.close = options.remove;
        delete options.remove;
      }
      if (options.quiet || options.silent) {
        options.silent = options.quiet || options.silent;
        delete options.quiet;
      }
      if (typeof options.sound !== "undefined") {
        options.s = options.sound;
        delete options.sound;
      }
      if (options.s === false) {
        options.silent = true;
        delete options.s;
      }
      if (options.s && options.silent) {
        delete options.s;
      }
      if (options.s === true) {
        options.s = toasterDefaultSound;
      }
      if (options.s && options.s.indexOf(toasterSoundPrefix) !== 0) {
        options.s = toasterDefaultSound;
      }
      if (options.actions && isArray(options.actions)) {
        options.b = options.actions.join(";");
        delete options.actions;
      }
      for (const key in options) {
        if (options.hasOwnProperty(key) && allowedToasterFlags.indexOf(key) === -1) {
          delete options[key];
        }
      }
      return options;
    };
    module.exports.mapToNotifu = function(options) {
      options = mapAppIcon(options);
      options = mapText(options);
      if (options.icon) {
        options.i = options.icon;
        delete options.icon;
      }
      if (options.message) {
        options.m = options.message;
        delete options.message;
      }
      if (options.title) {
        options.p = options.title;
        delete options.title;
      }
      if (options.time) {
        options.d = options.time;
        delete options.time;
      }
      if (options.q !== false) {
        options.q = true;
      } else {
        delete options.q;
      }
      if (options.quiet === false) {
        delete options.q;
        delete options.quiet;
      }
      if (options.sound) {
        delete options.q;
        delete options.sound;
      }
      if (options.t) {
        options.d = options.t;
        delete options.t;
      }
      if (options.type) {
        options.t = sanitizeNotifuTypeArgument(options.type);
        delete options.type;
      }
      return options;
    };
    module.exports.isMac = function() {
      return os.type() === "Darwin";
    };
    module.exports.isMountainLion = function() {
      return os.type() === "Darwin" && semver.satisfies(garanteeSemverFormat(os.release()), ">=12.0.0");
    };
    module.exports.isWin8 = function() {
      return os.type() === "Windows_NT" && semver.satisfies(garanteeSemverFormat(os.release()), ">=6.2.9200");
    };
    module.exports.isWSL = function() {
      return isWSL;
    };
    module.exports.isLessThanWin8 = function() {
      return os.type() === "Windows_NT" && semver.satisfies(garanteeSemverFormat(os.release()), "<6.2.9200");
    };
    function garanteeSemverFormat(version2) {
      if (version2.split(".").length === 2) {
        version2 += ".0";
      }
      return version2;
    }
    function sanitizeNotifuTypeArgument(type) {
      if (typeof type === "string" || type instanceof String) {
        if (type.toLowerCase() === "info")
          return "info";
        if (type.toLowerCase() === "warn")
          return "warn";
        if (type.toLowerCase() === "error")
          return "error";
      }
      return "info";
    }
    module.exports.createNamedPipe = (server) => {
      const buf = Buffer.alloc(BUFFER_SIZE);
      return new Promise((resolve) => {
        server.instance = net.createServer((stream) => {
          stream.on("data", (c) => {
            buf.write(c.toString());
          });
          stream.on("end", () => {
            server.instance.close();
          });
        });
        server.instance.listen(server.namedPipe, () => {
          resolve(buf);
        });
      });
    };
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = require_fs();
    function checkPathExt(path, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), path, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = require_fs();
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module) {
    var fs = require_fs();
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path, options) {
      try {
        return core.sync(path, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = require_path();
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module.exports = which;
    which.sync = whichSync;
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-notifier/notifiers/notifysend.js
var require_notifysend = __commonJS({
  "node_modules/node-notifier/notifiers/notifysend.js"(exports, module) {
    var os = require_os();
    var which = require_which();
    var utils = require_utils();
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var notifier = "notify-send";
    var hasNotifier;
    module.exports = NotifySend;
    function NotifySend(options) {
      options = utils.clone(options || {});
      if (!(this instanceof NotifySend)) {
        return new NotifySend(options);
      }
      this.options = options;
      EventEmitter.call(this);
    }
    util.inherits(NotifySend, EventEmitter);
    function noop() {
    }
    function notifyRaw(options, callback) {
      options = utils.clone(options || {});
      callback = callback || noop;
      if (typeof callback !== "function") {
        throw new TypeError(
          "The second argument must be a function callback. You have passed " + typeof callback
        );
      }
      if (typeof options === "string") {
        options = { title: "node-notifier", message: options };
      }
      if (!options.message) {
        callback(new Error("Message is required."));
        return this;
      }
      if (os.type() !== "Linux" && !os.type().match(/BSD$/)) {
        callback(new Error("Only supported on Linux and *BSD systems"));
        return this;
      }
      if (hasNotifier === false) {
        callback(new Error("notify-send must be installed on the system."));
        return this;
      }
      if (hasNotifier || !!this.options.suppressOsdCheck) {
        doNotification(options, callback);
        return this;
      }
      try {
        hasNotifier = !!which.sync(notifier);
        doNotification(options, callback);
      } catch (err) {
        hasNotifier = false;
        return callback(err);
      }
      return this;
    }
    Object.defineProperty(NotifySend.prototype, "notify", {
      get: function() {
        if (!this._notify)
          this._notify = notifyRaw.bind(this);
        return this._notify;
      }
    });
    var allowedArguments = ["urgency", "expire-time", "icon", "category", "hint", "app-name"];
    function doNotification(options, callback) {
      options = utils.mapToNotifySend(options);
      options.title = options.title || "Node Notification:";
      const initial = [options.title, options.message];
      delete options.title;
      delete options.message;
      const argsList = utils.constructArgumentList(options, {
        initial,
        keyExtra: "-",
        allowedArguments
      });
      utils.command(notifier, argsList, callback);
    }
  }
});

// node_modules/node-notifier/lib/checkGrowl.js
var require_checkGrowl = __commonJS({
  "node_modules/node-notifier/lib/checkGrowl.js"(exports, module) {
    var net = require_net();
    var hasGrowl = false;
    module.exports = function(growlConfig, cb) {
      if (typeof cb === "undefined") {
        cb = growlConfig;
        growlConfig = {};
      }
      if (hasGrowl)
        return cb(null, hasGrowl);
      const port = growlConfig.port || 23053;
      const host = growlConfig.host || "localhost";
      const socket = net.connect(port, host);
      socket.setTimeout(100);
      socket.once("connect", function() {
        socket.end();
        cb(null, true);
      });
      socket.once("error", function() {
        socket.end();
        cb(null, false);
      });
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/growly/lib/gntp.js
var require_gntp = __commonJS({
  "node_modules/growly/lib/gntp.js"(exports, module) {
    var net = require_net();
    var crypto2 = require_crypto();
    var format = require_util().format;
    var fs = require_fs();
    var nl = "\r\n";
    function GNTP(type, opts) {
      opts = opts || {};
      this.type = type;
      this.host = opts.host || "localhost";
      this.port = opts.port || 23053;
      this.request = "GNTP/1.0 " + type + " NONE" + nl;
      this.resources = [];
      this.attempts = 0;
      this.maxAttempts = 5;
    }
    GNTP.prototype.parseResp = function(resp) {
      var parsed = {}, head, body;
      resp = resp.slice(0, resp.indexOf(nl + nl)).split(nl);
      head = resp[0];
      body = resp.slice(1);
      parsed.state = head.match(/-(OK|ERROR|CALLBACK)/)[0].slice(1);
      body.forEach(function(ln) {
        ln = ln.split(": ");
        parsed[ln[0]] = ln[1];
      });
      return parsed;
    };
    GNTP.prototype.retry = function() {
      var self = this, args = arguments;
      setTimeout(function() {
        self.send.apply(self, args);
      }, 750);
    };
    GNTP.prototype.addResource = function(file) {
      var id = crypto2.createHash("md5").update(file).digest("hex"), header = "Identifier: " + id + nl + "Length: " + file.length + nl + nl;
      this.resources.push({ header, file });
      return "x-growl-resource://" + id;
    };
    GNTP.prototype.add = function(name, val) {
      if (val === void 0)
        return;
      if (/-Icon/.test(name) && !/^https?:\/\//.test(val)) {
        if (/\.(png|gif|jpe?g)$/.test(val))
          val = this.addResource(fs.readFileSync(val));
        else if (val instanceof Buffer)
          val = this.addResource(val);
      }
      this.request += name + ": " + val + nl;
    };
    GNTP.prototype.newline = function() {
      this.request += nl;
    };
    GNTP.prototype.send = function(callback) {
      var self = this, socket = net.connect(this.port, this.host), resp = "";
      callback = callback || function() {
      };
      this.attempts += 1;
      socket.on("connect", function() {
        socket.write(self.request);
        self.resources.forEach(function(res) {
          socket.write(res.header);
          socket.write(res.file);
          socket.write(nl + nl);
        });
      });
      socket.on("data", function(data) {
        resp += data.toString();
        if (resp.slice(resp.length - 4) !== nl + nl)
          return;
        resp = self.parseResp(resp);
        if (resp.state === "ERROR" || resp.state === "CALLBACK")
          socket.end();
        else
          resp = "";
      });
      socket.on("end", function() {
        if (["200", "401", "402"].indexOf(resp["Error-Code"]) >= 0) {
          if (self.attempts <= self.maxAttempts) {
            self.retry(callback);
          } else {
            var msg = 'GNTP request to "%s:%d" failed with error code %s (%s)';
            callback(new Error(format(msg, self.host, self.port, resp["Error-Code"], resp["Error-Description"])));
          }
        } else {
          callback(void 0, resp);
        }
      });
      socket.on("error", function() {
        callback(new Error(format('Error while sending GNTP request to "%s:%d"', self.host, self.port)));
        socket.destroy();
      });
    };
    module.exports = GNTP;
  }
});

// node_modules/growly/lib/growly.js
var require_growly = __commonJS({
  "node_modules/growly/lib/growly.js"(exports, module) {
    var GNTP = require_gntp();
    function Growly() {
      this.appname = "Growly";
      this.notifications = void 0;
      this.labels = void 0;
      this.count = 0;
      this.registered = false;
      this.host = void 0;
      this.port = void 0;
    }
    Growly.prototype.getLabels = function() {
      return this.notifications.map(function(notif) {
        return notif.label;
      });
    };
    Growly.prototype.setHost = function(host, port) {
      this.host = host;
      this.port = port;
    };
    Growly.prototype.register = function(appname, appicon, notifications, callback) {
      var gntp;
      if (typeof appicon === "object") {
        notifications = appicon;
        appicon = void 0;
      }
      if (notifications === void 0 || !notifications.length) {
        notifications = [{ label: "default", dispname: "Default Notification", enabled: true }];
      }
      if (typeof arguments[arguments.length - 1] === "function") {
        callback = arguments[arguments.length - 1];
      } else {
        callback = function() {
        };
      }
      this.appname = appname;
      this.notifications = notifications;
      this.labels = this.getLabels();
      this.registered = true;
      gntp = new GNTP("REGISTER", { host: this.host, port: this.port });
      gntp.add("Application-Name", appname);
      gntp.add("Application-Icon", appicon);
      gntp.add("Notifications-Count", notifications.length);
      gntp.newline();
      notifications.forEach(function(notif) {
        if (notif.enabled === void 0)
          notif.enabled = true;
        gntp.add("Notification-Name", notif.label);
        gntp.add("Notification-Display-Name", notif.dispname);
        gntp.add("Notification-Enabled", notif.enabled ? "True" : "False");
        gntp.add("Notification-Icon", notif.icon);
        gntp.newline();
      });
      gntp.send(callback);
    };
    Growly.prototype.notify = function(text, opts, callback) {
      var self = this, gntp;
      if (!this.registered) {
        this.register(this.appname, function(err) {
          if (err)
            console.log(err);
          self.notify.call(self, text, opts, callback);
        });
        return;
      }
      opts = opts || {};
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      gntp = new GNTP("NOTIFY", { host: this.host, port: this.port });
      gntp.add("Application-Name", this.appname);
      gntp.add("Notification-Name", opts.label || this.labels[0]);
      gntp.add("Notification-ID", ++this.count);
      gntp.add("Notification-Title", opts.title);
      gntp.add("Notification-Text", text);
      gntp.add("Notification-Sticky", opts.sticky ? "True" : "False");
      gntp.add("Notification-Priority", opts.priority);
      gntp.add("Notification-Icon", opts.icon);
      gntp.add("Notification-Coalescing-ID", opts.coalescingId || void 0);
      gntp.add("Notification-Callback-Context", callback ? "context" : void 0);
      gntp.add("Notification-Callback-Context-Type", callback ? "string" : void 0);
      gntp.add("Notification-Callback-Target", void 0);
      gntp.newline();
      gntp.send(function(err, resp) {
        if (callback && err) {
          callback(err);
        } else if (callback && resp.state === "CALLBACK") {
          callback(void 0, resp["Notification-Callback-Result"].toLowerCase());
        }
      });
    };
    module.exports = new Growly();
  }
});

// node_modules/node-notifier/notifiers/growl.js
var require_growl = __commonJS({
  "node_modules/node-notifier/notifiers/growl.js"(exports, module) {
    var checkGrowl = require_checkGrowl();
    var utils = require_utils();
    var growly = require_growly();
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var errorMessageNotFound = "Couldn't connect to growl (might be used as a fallback). Make sure it is running";
    module.exports = Growl;
    var hasGrowl;
    function Growl(options) {
      options = utils.clone(options || {});
      if (!(this instanceof Growl)) {
        return new Growl(options);
      }
      growly.appname = options.name || "Node";
      this.options = options;
      EventEmitter.call(this);
    }
    util.inherits(Growl, EventEmitter);
    function notifyRaw(options, callback) {
      growly.setHost(this.options.host, this.options.port);
      options = utils.clone(options || {});
      if (typeof options === "string") {
        options = { title: "node-notifier", message: options };
      }
      callback = utils.actionJackerDecorator(this, options, callback, function(data) {
        if (data === "click") {
          return "click";
        }
        if (data === "timedout") {
          return "timeout";
        }
        return false;
      });
      options = utils.mapToGrowl(options);
      if (!options.message) {
        callback(new Error("Message is required."));
        return this;
      }
      options.title = options.title || "Node Notification:";
      if (hasGrowl || !!options.wait) {
        const localCallback = options.wait ? callback : noop;
        growly.notify(options.message, options, localCallback);
        if (!options.wait)
          callback();
        return this;
      }
      checkGrowl(growly, function(_, didHaveGrowl) {
        hasGrowl = didHaveGrowl;
        if (!didHaveGrowl)
          return callback(new Error(errorMessageNotFound));
        growly.notify(options.message, options);
        callback();
      });
      return this;
    }
    Object.defineProperty(Growl.prototype, "notify", {
      get: function() {
        if (!this._notify)
          this._notify = notifyRaw.bind(this);
        return this._notify;
      }
    });
    function noop() {
    }
  }
});

// node_modules/node-notifier/notifiers/notificationcenter.js
var require_notificationcenter = __commonJS({
  "node_modules/node-notifier/notifiers/notificationcenter.js"(exports, module) {
    var utils = require_utils();
    var Growl = require_growl();
    var path = require_path();
    var notifier = path.join(
      __dirname,
      "../vendor/mac.noindex/terminal-notifier.app/Contents/MacOS/terminal-notifier"
    );
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var errorMessageOsX = "You need Mac OS X 10.8 or above to use NotificationCenter, or use Growl fallback with constructor option {withFallback: true}.";
    module.exports = NotificationCenter;
    function NotificationCenter(options) {
      options = utils.clone(options || {});
      if (!(this instanceof NotificationCenter)) {
        return new NotificationCenter(options);
      }
      this.options = options;
      EventEmitter.call(this);
    }
    util.inherits(NotificationCenter, EventEmitter);
    var activeId = null;
    function noop() {
    }
    function notifyRaw(options, callback) {
      let fallbackNotifier;
      const id = identificator();
      options = utils.clone(options || {});
      activeId = id;
      if (typeof options === "string") {
        options = { title: "node-notifier", message: options };
      }
      callback = callback || noop;
      if (typeof callback !== "function") {
        throw new TypeError(
          "The second argument must be a function callback. You have passed " + typeof fn
        );
      }
      const actionJackedCallback = utils.actionJackerDecorator(
        this,
        options,
        callback,
        function(data) {
          if (activeId !== id)
            return false;
          if (data === "activate") {
            return "click";
          }
          if (data === "timeout") {
            return "timeout";
          }
          if (data === "replied") {
            return "replied";
          }
          return false;
        }
      );
      options = utils.mapToMac(options);
      if (!options.message && !options.group && !options.list && !options.remove) {
        callback(new Error("Message, group, remove or list property is required."));
        return this;
      }
      const argsList = utils.constructArgumentList(options);
      if (utils.isMountainLion()) {
        utils.fileCommandJson(
          this.options.customPath || notifier,
          argsList,
          actionJackedCallback
        );
        return this;
      }
      if (fallbackNotifier || !!this.options.withFallback) {
        fallbackNotifier = fallbackNotifier || new Growl(this.options);
        return fallbackNotifier.notify(options, callback);
      }
      callback(new Error(errorMessageOsX));
      return this;
    }
    Object.defineProperty(NotificationCenter.prototype, "notify", {
      get: function() {
        if (!this._notify)
          this._notify = notifyRaw.bind(this);
        return this._notify;
      }
    });
    function identificator() {
      return { _ref: "val" };
    }
  }
});

// node_modules/node-notifier/notifiers/balloon.js
var require_balloon = __commonJS({
  "node_modules/node-notifier/notifiers/balloon.js"(exports, module) {
    var path = require_path();
    var notifier = path.resolve(__dirname, "../vendor/notifu/notifu");
    var checkGrowl = require_checkGrowl();
    var utils = require_utils();
    var Toaster = require_toaster();
    var Growl = require_growl();
    var os = require_os();
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var hasGrowl;
    module.exports = WindowsBalloon;
    function WindowsBalloon(options) {
      options = utils.clone(options || {});
      if (!(this instanceof WindowsBalloon)) {
        return new WindowsBalloon(options);
      }
      this.options = options;
      EventEmitter.call(this);
    }
    util.inherits(WindowsBalloon, EventEmitter);
    function noop() {
    }
    function notifyRaw(options, callback) {
      let fallback;
      const notifierOptions = this.options;
      options = utils.clone(options || {});
      callback = callback || noop;
      if (typeof options === "string") {
        options = { title: "node-notifier", message: options };
      }
      const actionJackedCallback = utils.actionJackerDecorator(
        this,
        options,
        callback,
        function(data) {
          if (data === "activate") {
            return "click";
          }
          if (data === "timeout") {
            return "timeout";
          }
          return false;
        }
      );
      if (!!this.options.withFallback && utils.isWin8()) {
        fallback = fallback || new Toaster(notifierOptions);
        return fallback.notify(options, callback);
      }
      if (!!this.options.withFallback && (!utils.isLessThanWin8() || hasGrowl === true)) {
        fallback = fallback || new Growl(notifierOptions);
        return fallback.notify(options, callback);
      }
      if (!this.options.withFallback || hasGrowl === false) {
        doNotification(options, notifierOptions, actionJackedCallback);
        return this;
      }
      checkGrowl(notifierOptions, function(_, hasGrowlResult) {
        hasGrowl = hasGrowlResult;
        if (hasGrowl) {
          fallback = fallback || new Growl(notifierOptions);
          return fallback.notify(options, callback);
        }
        doNotification(options, notifierOptions, actionJackedCallback);
      });
      return this;
    }
    Object.defineProperty(WindowsBalloon.prototype, "notify", {
      get: function() {
        if (!this._notify)
          this._notify = notifyRaw.bind(this);
        return this._notify;
      }
    });
    var allowedArguments = ["t", "d", "p", "m", "i", "e", "q", "w", "xp"];
    function doNotification(options, notifierOptions, callback) {
      const is64Bit = os.arch() === "x64";
      options = options || {};
      options = utils.mapToNotifu(options);
      options.p = options.p || "Node Notification:";
      const fullNotifierPath = notifier + (is64Bit ? "64" : "") + ".exe";
      const localNotifier = notifierOptions.customPath || fullNotifierPath;
      if (!options.m) {
        callback(new Error("Message is required."));
        return this;
      }
      const argsList = utils.constructArgumentList(options, {
        wrapper: "",
        noEscape: true,
        explicitTrue: true,
        allowedArguments
      });
      if (options.wait) {
        return utils.fileCommand(localNotifier, argsList, function(error, data) {
          const action = fromErrorCodeToAction(error.code);
          if (action === "error")
            return callback(error, data);
          return callback(null, action);
        });
      }
      utils.immediateFileCommand(localNotifier, argsList, callback);
    }
    function fromErrorCodeToAction(errorCode) {
      switch (errorCode) {
        case 2:
          return "timeout";
        case 3:
        case 6:
        case 7:
          return "activate";
        case 4:
          return "close";
        default:
          return "error";
      }
    }
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/node-notifier/node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/node-notifier/node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/node-notifier/notifiers/toaster.js
var require_toaster = __commonJS({
  "node_modules/node-notifier/notifiers/toaster.js"(exports, module) {
    var path = require_path();
    var notifier = path.resolve(__dirname, "../vendor/snoreToast/snoretoast");
    var utils = require_utils();
    var Balloon = require_balloon();
    var os = require_os();
    var { v4: uuid } = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var fallback;
    var PIPE_NAME = "notifierPipe";
    var PIPE_PATH_PREFIX = "\\\\.\\pipe\\";
    var PIPE_PATH_PREFIX_WSL = "/tmp/";
    module.exports = WindowsToaster;
    function WindowsToaster(options) {
      options = utils.clone(options || {});
      if (!(this instanceof WindowsToaster)) {
        return new WindowsToaster(options);
      }
      this.options = options;
      EventEmitter.call(this);
    }
    util.inherits(WindowsToaster, EventEmitter);
    function noop() {
    }
    function parseResult(data) {
      if (!data) {
        return {};
      }
      return data.split(";").reduce((acc, cur) => {
        const split = cur.split("=");
        if (split && split.length === 2) {
          acc[split[0]] = split[1];
        }
        return acc;
      }, {});
    }
    function getPipeName() {
      const pathPrefix = utils.isWSL() ? PIPE_PATH_PREFIX_WSL : PIPE_PATH_PREFIX;
      return `${pathPrefix}${PIPE_NAME}-${uuid()}`;
    }
    function notifyRaw(options, callback) {
      options = utils.clone(options || {});
      callback = callback || noop;
      const is64Bit = os.arch() === "x64";
      let resultBuffer;
      const server = {
        namedPipe: getPipeName()
      };
      if (typeof options === "string") {
        options = { title: "node-notifier", message: options };
      }
      if (typeof callback !== "function") {
        throw new TypeError(
          "The second argument must be a function callback. You have passed " + typeof fn
        );
      }
      const snoreToastResultParser = (err, callback2) => {
        const result = parseResult(
          resultBuffer && resultBuffer.toString("utf16le")
        );
        if (result.action === "buttonClicked" && result.button) {
          result.activationType = result.button;
        } else if (result.action) {
          result.activationType = result.action;
        }
        if (err && err.code === -1) {
          callback2(err, result);
        }
        callback2(null, result);
        server.instance && server.instance.close();
      };
      const actionJackedCallback = (err) => snoreToastResultParser(
        err,
        utils.actionJackerDecorator(
          this,
          options,
          callback,
          (data) => data === "activate" ? "click" : data || false
        )
      );
      options.title = options.title || "Node Notification:";
      if (typeof options.message === "undefined" && typeof options.close === "undefined") {
        callback(new Error("Message or ID to close is required."));
        return this;
      }
      if (!utils.isWin8() && !utils.isWSL() && !!this.options.withFallback) {
        fallback = fallback || new Balloon(this.options);
        return fallback.notify(options, callback);
      }
      utils.createNamedPipe(server).then((out) => {
        resultBuffer = out;
        options.pipeName = server.namedPipe;
        const localNotifier = options.customPath || this.options.customPath || notifier + "-x" + (is64Bit ? "64" : "86") + ".exe";
        options = utils.mapToWin8(options);
        const argsList = utils.constructArgumentList(options, {
          explicitTrue: true,
          wrapper: "",
          keepNewlines: true,
          noEscape: true
        });
        utils.fileCommand(
          localNotifier,
          argsList,
          actionJackedCallback
        );
      });
      return this;
    }
    Object.defineProperty(WindowsToaster.prototype, "notify", {
      get: function() {
        if (!this._notify)
          this._notify = notifyRaw.bind(this);
        return this._notify;
      }
    });
  }
});

// node_modules/node-notifier/index.js
var require_node_notifier = __commonJS({
  "node_modules/node-notifier/index.js"(exports, module) {
    var os = require_os();
    var utils = require_utils();
    var NotifySend = require_notifysend();
    var NotificationCenter = require_notificationcenter();
    var WindowsToaster = require_toaster();
    var Growl = require_growl();
    var WindowsBalloon = require_balloon();
    var options = { withFallback: true };
    var osType = utils.isWSL() ? "WSL" : os.type();
    switch (osType) {
      case "Linux":
        module.exports = new NotifySend(options);
        module.exports.Notification = NotifySend;
        break;
      case "Darwin":
        module.exports = new NotificationCenter(options);
        module.exports.Notification = NotificationCenter;
        break;
      case "Windows_NT":
        if (utils.isLessThanWin8()) {
          module.exports = new WindowsBalloon(options);
          module.exports.Notification = WindowsBalloon;
        } else {
          module.exports = new WindowsToaster(options);
          module.exports.Notification = WindowsToaster;
        }
        break;
      case "WSL":
        module.exports = new WindowsToaster(options);
        module.exports.Notification = WindowsToaster;
        break;
      default:
        if (os.type().match(/BSD$/)) {
          module.exports = new NotifySend(options);
          module.exports.Notification = NotifySend;
        } else {
          module.exports = new Growl(options);
          module.exports.Notification = Growl;
        }
    }
    module.exports.NotifySend = NotifySend;
    module.exports.NotificationCenter = NotificationCenter;
    module.exports.WindowsToaster = WindowsToaster;
    module.exports.WindowsBalloon = WindowsBalloon;
    module.exports.Growl = Growl;
  }
});
export default require_node_notifier();
//# sourceMappingURL=node-notifier.js.map
